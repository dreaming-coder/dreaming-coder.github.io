import{_ as s,o as n,c as a,a as p}from"./app.a99c6d03.js";const l="/imgs/golang/slice/slice-001.png",d=JSON.parse('{"title":"GoLang - Slice","description":"","frontmatter":{},"headers":[{"level":2,"title":"make 创建切片","slug":"make-创建切片","link":"#make-创建切片","children":[]},{"level":2,"title":"切片重组","slug":"切片重组","link":"#切片重组","children":[]},{"level":2,"title":"append 函数","slug":"append-函数","link":"#append-函数","children":[]}],"relativePath":"md/golang/go-slice.md","lastUpdated":1674825208000}'),o={name:"md/golang/go-slice.md"},e=p(`<h1 id="golang-slice" tabindex="-1">GoLang - Slice <a class="header-anchor" href="#golang-slice" aria-hidden="true">#</a></h1><p><strong>切片（<code>slice</code>）</strong> 是对底层数组一个连续片段的引用，所以<strong>切片是一个引用类型</strong>。切片提供对该数组中编号的元素序列的访问。未初始化切片的值为 <code>nil</code>。</p><p>与数组一样，切片是可索引的并且具有长度。切片 <code>s</code> 的长度可以通过内置函数 <code>len() </code> 获取；与数组不同，切片的长度可能在执行期间发生变化。元素可以通过整数索引 <code>0</code> 到 <code>len(s)-1</code> 来寻址。我们可以把切片看成是一个长度可变的数组。</p><p>切片提供了计算容量的函数 <code>cap()</code> ，可以测量切片最大长度。切片的长度永远不会超过它的容量，所以对于切片 <code>s</code> 来说，这个不等式永远成立：<code>0 &lt;= len(s) &lt;= cap(s)</code>。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>多个切片如果表示同一个数组的片段，它们可以共享数据；因此一个切片和相关数组的其他切片是共享存储的，相反，不同的数组总是代表不同的存储。数组实际上是切片的构建块。</p></div><p>切片可以延伸超过切片的末端，容量是切片长度与切片之外的数组长度的总和。</p><blockquote><p>使用内置函数 <code>make()</code> 可以给切片初始化，该函数指定切片类型和指定长度和可选容量的参数。</p></blockquote><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>绝对不要用指针指向 <code>slice</code>。切片本身已经是一个引用类型，所以它本身就是一个指针!!</p></div><p>下图显示了表示一年中每个月份名字的字符串数组，还有重叠引用了该数组的两个 slice。数组这样定义：</p><div class="language-go"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">months </span><span style="color:#89DDFF;">:=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[...]</span><span style="color:#C792EA;">string</span><span style="color:#89DDFF;">{</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">January</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;">/* ... */</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">12</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">December</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>因此一月份是 <code>months[1]</code>，十二月份是 <code>months[12]</code>。通常，数组的第一个元素从索引 <code>0</code> 开始，但是月份一般是从 <code>1</code> 开始的，因此我们声明数组时直接跳过第 0 个元素，第 0 个元素会被自动初始化为空字符串。</p><p>让我们分别定义表示第二季度和北方夏天月份的 slice，它们有重叠部分：</p><p><img src="`+l+`" alt=""></p><div class="language-go"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">Q2 </span><span style="color:#89DDFF;">:=</span><span style="color:#A6ACCD;"> months</span><span style="color:#89DDFF;">[</span><span style="color:#F78C6C;">4</span><span style="color:#89DDFF;">:</span><span style="color:#F78C6C;">7</span><span style="color:#89DDFF;">]</span></span>
<span class="line"><span style="color:#A6ACCD;">summer </span><span style="color:#89DDFF;">:=</span><span style="color:#A6ACCD;"> months</span><span style="color:#89DDFF;">[</span><span style="color:#F78C6C;">6</span><span style="color:#89DDFF;">:</span><span style="color:#F78C6C;">9</span><span style="color:#89DDFF;">]</span></span>
<span class="line"><span style="color:#A6ACCD;">fmt</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">Println</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">Q2</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;">     </span><span style="color:#676E95;">// [&quot;April&quot; &quot;May&quot; &quot;June&quot;]</span></span>
<span class="line"><span style="color:#A6ACCD;">fmt</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">Println</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">summer</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;">// [&quot;June&quot; &quot;July&quot; &quot;August&quot;]</span></span>
<span class="line"></span></code></pre></div><p>两个 slice 都包含了六月份，下面的代码是一个包含相同月份的测试（性能较低）：</p><div class="language-go"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki"><code><span class="line"><span style="color:#89DDFF;">for</span><span style="color:#A6ACCD;"> _</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> s </span><span style="color:#89DDFF;">:=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">range</span><span style="color:#A6ACCD;"> summer </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">for</span><span style="color:#A6ACCD;"> _</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> q </span><span style="color:#89DDFF;">:=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">range</span><span style="color:#A6ACCD;"> Q2 </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">if</span><span style="color:#A6ACCD;"> s </span><span style="color:#89DDFF;">==</span><span style="color:#A6ACCD;"> q </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">            fmt</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">Printf</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">%s appears in both</span><span style="color:#A6ACCD;">\\n</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> s</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>如果切片操作超出 <code>cap(s)</code> 的上限将导致一个 <code>panic</code> 异常，但是超出 <code>len(s)</code> 则是意味着扩展了 <code>slice</code>，因为新 <code>slice</code> 的长度会变大：</p><div class="language-go"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">fmt</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">Println</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">summer</span><span style="color:#89DDFF;">[:</span><span style="color:#F78C6C;">20</span><span style="color:#89DDFF;">])</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;">// panic: out of range</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">endlessSummer </span><span style="color:#89DDFF;">:=</span><span style="color:#A6ACCD;"> summer</span><span style="color:#89DDFF;">[:</span><span style="color:#F78C6C;">5</span><span style="color:#89DDFF;">]</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;">// extend a slice (within capacity)</span></span>
<span class="line"><span style="color:#A6ACCD;">fmt</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">Println</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">endlessSummer</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;">  </span><span style="color:#676E95;">// &quot;[June July August September October]&quot;</span></span>
<span class="line"></span></code></pre></div><p>另外，字符串的切片操作和 <code>[]byte</code> 字节类型切片的切片操作是类似的。都写作 <code>x[m:n]</code>，并且都是返回一个原始字节序列的子序列，底层都是共享之前的底层数组，因此这种操作都是常量时间复杂度。<code>x[m:n]</code> 切片操作对于字符串则生成一个新字符串，如果 <code>x</code> 是 <code>[]byte</code> 的话则生成一个新的 <code>[]byte</code>。</p><h2 id="make-创建切片" tabindex="-1">make 创建切片 <a class="header-anchor" href="#make-创建切片" aria-hidden="true">#</a></h2><p>当相关数组还没有定义时，我们可以使用 <code>make()</code> 函数来创建一个切片 同时创建好相关数组</p><div class="language-go"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">slice1 </span><span style="color:#89DDFF;">:=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">make</span><span style="color:#89DDFF;">([]</span><span style="color:#A6ACCD;">type</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> len</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">slice1 </span><span style="color:#89DDFF;">:=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">make</span><span style="color:#89DDFF;">([]</span><span style="color:#A6ACCD;">type</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> len</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> cap</span><span style="color:#89DDFF;">)</span></span>
<span class="line"></span></code></pre></div><p>如果从数组或者切片中生成一个新的切片，我们可以使用下面的表达式：</p><div class="language-go"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">ary</span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;">low </span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> high </span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> max</span><span style="color:#89DDFF;">]</span></span>
<span class="line"></span></code></pre></div><blockquote><p><code>max-low</code> 的结果表示容量，<code>high-low</code> 的结果表示长度。</p></blockquote><h2 id="切片重组" tabindex="-1">切片重组 <a class="header-anchor" href="#切片重组" aria-hidden="true">#</a></h2><p>通过改变切片长度得到新切片的过程称之为切片重组 (<code>reslicing</code>)</p><div class="language-go"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">slice1 </span><span style="color:#89DDFF;">:=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">make</span><span style="color:#89DDFF;">([]</span><span style="color:#A6ACCD;">type</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> start_length</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> capacity</span><span style="color:#89DDFF;">)</span></span>
<span class="line"></span></code></pre></div><p><strong>当我们在一个切片基础上重新划分一个切片时，新的切片会继续引用原有切片的数组</strong>。如果你忘了这个行为的话，在你的应用分配大量临时的切片用于创建新的切片来引用原有数据的一小部分时，会导致难以预期的内存使用。</p><p>简单说，有一个切片长度和容量都是10000，你现在却只需要使用其中的三个元素，如下所示：</p><div class="language-go"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki"><code><span class="line"><span style="color:#89DDFF;">package</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">main</span></span>
<span class="line"><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#89DDFF;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#FFCB6B;">fmt</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#89DDFF;">func</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">get</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[]</span><span style="color:#C792EA;">byte</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#A6ACCD;">    raw </span><span style="color:#89DDFF;">:=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">make</span><span style="color:#89DDFF;">([]</span><span style="color:#C792EA;">byte</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">10000</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">    fmt</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">Println</span><span style="color:#89DDFF;">(</span><span style="color:#82AAFF;">len</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">raw</span><span style="color:#89DDFF;">),</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">cap</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">raw</span><span style="color:#89DDFF;">),</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&amp;</span><span style="color:#A6ACCD;">raw</span><span style="color:#89DDFF;">[</span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">])</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;">// 输出: 10000 10000 数组首字节地址</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">return</span><span style="color:#A6ACCD;"> raw</span><span style="color:#89DDFF;">[:</span><span style="color:#F78C6C;">3</span><span style="color:#89DDFF;">]</span><span style="color:#A6ACCD;">  </span><span style="color:#676E95;">// 10000个字节实际只需要引用3个，其他空间浪费</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#89DDFF;">func</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">main</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#A6ACCD;">    data </span><span style="color:#89DDFF;">:=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">get</span><span style="color:#89DDFF;">()</span></span>
<span class="line"><span style="color:#A6ACCD;">    fmt</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">Println</span><span style="color:#89DDFF;">(</span><span style="color:#82AAFF;">len</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">data</span><span style="color:#89DDFF;">),</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">cap</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">data</span><span style="color:#89DDFF;">),</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&amp;</span><span style="color:#A6ACCD;">data</span><span style="color:#89DDFF;">[</span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">])</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;">// 输出: 3 10000 数组首字节地址</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>上面的代码原因很简单，对切片进行切片，由于切片是引用类型，所以如果你原切片占用空间很多，而现在只需要一点点的数据，那么最好不要用切片，而应该用 <code>copy</code> 函数，将少部分的数据复制出来，这样就可以释放原切片空间。</p><div class="language-go"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki"><code><span class="line"><span style="color:#89DDFF;">func</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">get</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[]</span><span style="color:#C792EA;">byte</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    raw </span><span style="color:#89DDFF;">:=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">make</span><span style="color:#89DDFF;">([]</span><span style="color:#C792EA;">byte</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">10000</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">    fmt</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">Println</span><span style="color:#89DDFF;">(</span><span style="color:#82AAFF;">len</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">raw</span><span style="color:#89DDFF;">),</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">cap</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">raw</span><span style="color:#89DDFF;">),</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&amp;</span><span style="color:#A6ACCD;">raw</span><span style="color:#89DDFF;">[</span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">])</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;">// 输出: 10000 10000 数组首字节地址</span></span>
<span class="line"><span style="color:#A6ACCD;">    res </span><span style="color:#89DDFF;">:=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">make</span><span style="color:#89DDFF;">([]</span><span style="color:#C792EA;">byte</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">3</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#82AAFF;">copy</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">res</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> raw</span><span style="color:#89DDFF;">[:</span><span style="color:#F78C6C;">3</span><span style="color:#89DDFF;">])</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;">// 利用 copy 函数复制，raw 可被GC释放</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">return</span><span style="color:#A6ACCD;"> res</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><h2 id="append-函数" tabindex="-1">append 函数 <a class="header-anchor" href="#append-函数" aria-hidden="true">#</a></h2><p>内置的 <code>append</code> 函数用于向 <code>slice</code> 追加元素：</p><div class="language-go"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki"><code><span class="line"><span style="color:#89DDFF;">func</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">append</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">s S</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> x </span><span style="color:#89DDFF;">...</span><span style="color:#A6ACCD;">T</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> S  </span><span style="color:#676E95;">// T是S元素类型</span></span>
<span class="line"></span></code></pre></div><p><code>append()</code> 函数将 <code>0</code> 个或多个具有相同类型 <code>S</code> 的元素追加到切片 <code>s</code> 后面并且返回新的切片；追加的元素必须和原切片的元素同类型。如果 <code>s</code> 的容量不足以存储新增元素，<code>append()</code> 会<strong>分配新的切片来保证已有切片元素和新增元素的存储</strong>。</p><p>因此，<strong><code>append()</code> 函数返回的切片可能已经指向一个不同的相关数组了</strong>。<code>append()</code> 函数总是返回成功，除非系统内存耗尽了。</p><div class="language-go"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">s0 </span><span style="color:#89DDFF;">:=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[]</span><span style="color:#C792EA;">int</span><span style="color:#89DDFF;">{</span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">s1 </span><span style="color:#89DDFF;">:=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">append</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">s0</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;">  </span><span style="color:#676E95;">// append 单个元素， [0, 0, 2]</span></span>
<span class="line"><span style="color:#A6ACCD;">s2 </span><span style="color:#89DDFF;">:=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">append</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">s1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">3</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">5</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">7</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;">  </span><span style="color:#676E95;">// append 多个元素， [0, 0, 2, 3, 5, 7]</span></span>
<span class="line"><span style="color:#A6ACCD;">s3 </span><span style="color:#89DDFF;">:=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">append</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">s2</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> s0</span><span style="color:#89DDFF;">...)</span><span style="color:#A6ACCD;">  </span><span style="color:#676E95;">// append 一个切片， [0, 0, 2, 3, 5, 7, 0, 0]</span></span>
<span class="line"><span style="color:#A6ACCD;">s4 </span><span style="color:#89DDFF;">:=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">append</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">s3</span><span style="color:#89DDFF;">[</span><span style="color:#F78C6C;">3</span><span style="color:#89DDFF;">:</span><span style="color:#F78C6C;">6</span><span style="color:#89DDFF;">],</span><span style="color:#A6ACCD;"> s3</span><span style="color:#89DDFF;">[</span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">:]...)</span><span style="color:#A6ACCD;">  </span><span style="color:#676E95;">// append 切片片段， [3, 5, 7, 2, 3, 5, 7, 0, 0]</span></span>
<span class="line"></span></code></pre></div><p><code>append()</code> 函数操作如果导致分配新的切片来保证已有切片元素和新增元素的存储，也就是返回的切片可能已经指向一个不同的相关数组了，那么新的切片已经和原来切片没有任何关系，即使修改了数据也不会同步。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p><strong><code>append()</code> 函数操作后，有没有生成新的切片需要看原有切片的容量是否足够</strong>。</p></div><p>有一个奇特之处，对一个切片 <code>s = []int{1,2,3,4,5}</code>：</p><div class="language-go"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki"><code><span class="line"><span style="color:#89DDFF;">package</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">main</span></span>
<span class="line"><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#89DDFF;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#FFCB6B;">fmt</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#89DDFF;">func</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">main</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    s </span><span style="color:#89DDFF;">:=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[]</span><span style="color:#C792EA;">int</span><span style="color:#89DDFF;">{</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">3</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">4</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">5</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">    p </span><span style="color:#89DDFF;">:=</span><span style="color:#A6ACCD;"> s</span><span style="color:#89DDFF;">[</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">:]</span></span>
<span class="line"><span style="color:#A6ACCD;">    q </span><span style="color:#89DDFF;">:=</span><span style="color:#A6ACCD;"> s</span><span style="color:#89DDFF;">[:</span><span style="color:#F78C6C;">4</span><span style="color:#89DDFF;">]</span></span>
<span class="line"><span style="color:#A6ACCD;">    fmt</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">Println</span><span style="color:#89DDFF;">(</span><span style="color:#82AAFF;">len</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">p</span><span style="color:#89DDFF;">),</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">cap</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">p</span><span style="color:#89DDFF;">))</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;">// 4  4</span></span>
<span class="line"><span style="color:#A6ACCD;">    fmt</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">Println</span><span style="color:#89DDFF;">(</span><span style="color:#82AAFF;">len</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">q</span><span style="color:#89DDFF;">),</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">cap</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">q</span><span style="color:#89DDFF;">))</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;">// 4  5</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div>`,43),c=[e];function t(r,D,F,y,C,A){return n(),a("div",null,c)}const g=s(o,[["render",t]]);export{d as __pageData,g as default};
