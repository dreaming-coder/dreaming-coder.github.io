import{_ as s,o as n,c as a,a as o}from"./app.aa5490e0.js";const y=JSON.parse('{"title":"GoLang - 代码结构化","description":"","frontmatter":{},"headers":[{"level":2,"title":"可见性规则","slug":"可见性规则","link":"#可见性规则","children":[]},{"level":2,"title":"包的概念","slug":"包的概念","link":"#包的概念","children":[]},{"level":2,"title":"包的导入","slug":"包的导入","link":"#包的导入","children":[]},{"level":2,"title":"标准库","slug":"标准库","link":"#标准库","children":[]},{"level":2,"title":"包的初始化","slug":"包的初始化","link":"#包的初始化","children":[]}],"relativePath":"md/golang/go-structure.md","lastUpdated":1674885557000}'),l={name:"md/golang/go-structure.md"},e=o(`<h1 id="golang-代码结构化" tabindex="-1">GoLang - 代码结构化 <a class="header-anchor" href="#golang-代码结构化" aria-hidden="true">#</a></h1><h2 id="可见性规则" tabindex="-1">可见性规则 <a class="header-anchor" href="#可见性规则" aria-hidden="true">#</a></h2><p>当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 private ）。</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>大写字母可以使用任何 Unicode 编码的字符，比如希腊文，不仅仅是 ASCII 码中的大写字母。</p></div><p>因此，在导入一个外部包后，能够且只能够访问该包中导出的对象。</p><p>假设在包 <code>pack1</code> 中我们有一个变量或函数叫做 <code>Thing</code>（以 T 开头，所以它能够被导出），那么在当前包中导入 <code>pack1</code> 包，Thing 就可以像面向对象语言那样使用点标记来调用：</p><div class="language-go"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">pack1</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">Thing </span><span style="color:#676E95;">//（pack1 在这里是不可以省略的）</span></span>
<span class="line"></span></code></pre></div><p>因此包也可以作为命名空间使用，帮助避免命名冲突（名称冲突）：两个包中的同名变量的区别在于他们的包名，例如 <code>pack1.Thing</code> 和 <code>pack2.Thing</code>。</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>如果你导入了一个包却没有使用它，则会在构建程序时引发错误，如 imported and not used: os，这正是遵循了 Go 的格言：“没有不必要的代码！”。</p></div><h2 id="包的概念" tabindex="-1">包的概念 <a class="header-anchor" href="#包的概念" aria-hidden="true">#</a></h2><p>包是结构化代码的一种方式：每个程序都由包（通常简称为 pkg）的概念组成，可以使用自身的包或者从其它包中导入内容。</p><p>如同其它一些编程语言中的类库或命名空间的概念，每个 Go 文件都属于且仅属于一个包。一个包可以由许多以 .go 为扩展名的源文件组成，因此文件名和包名一般来说都是不相同的。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p><strong>每个目录下面可以有多个.go文件，这些文件只能属于同一个包</strong>，否则编译时会报错。<strong>同一个包下的不同.go文件相互之间可以直接引用变量和函数</strong>，所以这些文件中定义的全局变量和函数不能重名。</p></div><p>你必须在源文件中非注释的第一行指明这个文件属于哪个包，如：<code>package main</code> 。</p><p><code>package main</code> 表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 <code>main</code> 的包。<code>package main</code> 包下可以有多个文件，但所有文件中只能有一个 <code>main()</code> 方法，<code>main()</code> 方法代表程序入口。</p><p>简单地说，在含有 <code>mian</code> 包的目录下，你可以写多个文件，每个文件非注释的第一行都使用 <code>package main</code> 来指明这些文件都属于这个应用的 <code>main</code> 包，只有一个文件能有 <code>main()</code> 方法，也就是应用程序的入口。<code>main</code> 包不是必须的，只有在可执行的应用程序中需要。</p><h2 id="包的导入" tabindex="-1">包的导入 <a class="header-anchor" href="#包的导入" aria-hidden="true">#</a></h2><p>一个 Go 程序通过 <code>import</code> 关键字将一组包链接在一起。<code>import</code> 其实是导入目录，而不是定义的包名称，实际应用中我们一般都会保持一致。</p><p>例如：<code>package big</code> ，我们 <code>import “math/big”</code> ，其实是在 <code>src</code> 中的 <code>src/math/big</code> 目录。在代码中使用 <code>big.Int</code> 时，<code>big</code> 指的才是 Go 文件中定义的 package 名字。</p><p>当<strong>导入多个包时，一般按照字母顺序排列</strong>包名称，像 GoLand 会在保存文件时自动完成这个动作。<strong>所谓导入包即等同于包含了这个包的所有的代码对象</strong>。</p><p>为避免名称冲突，<strong>同一包中所有对象的标识符必须要求唯一</strong>。但是<strong>相同的标识符可以在不同的包中使用，因为可以使用包名来区分它们</strong>。</p><p><code>import</code> 语句一般放在包名定义的下一行，导入包示例如下：</p><div class="language-go"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki"><code><span class="line"><span style="color:#89DDFF;">package</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">main</span></span>
<span class="line"><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#89DDFF;">import</span><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#FFCB6B;">context</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">  </span><span style="color:#676E95;">//加载context包</span></span>
<span class="line"></span></code></pre></div><p>导入多个包的常见的方式是：</p><div class="language-go"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki"><code><span class="line"><span style="color:#89DDFF;">import</span><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">(</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#FFCB6B;">fmt</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#FFCB6B;">net/http</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">)</span></span>
<span class="line"></span></code></pre></div><p>调用导入的包函数的一般方式：</p><div class="language-go"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">fmt</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">Println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Hello World!</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">)</span></span>
<span class="line"></span></code></pre></div><p>下面介绍三种特殊的 <code>import</code> 方式：</p><ul><li><p>点操作：<code>import . &quot;fmt&quot;</code></p><p>点操作的含义是某个包导入之后，在调用这个包的函数时，可以省略前缀的包名，如这里可以写成 <code>Println(&quot;Hello World!&quot;)</code>，而不是 <code>fmt.Println(&quot;Hello World!&quot;)</code>。</p></li><li><p>别名操作：<code>import f &quot;fmt&quot;</code></p><p>别名操作调用包函数时，前缀变成了别名，即 <code>f.Println(&quot;Hello World!&quot;)</code>。在实际项目中有时这样使用，但请谨慎使用，不要不加节制地采用这种形式。</p></li><li><p><code>_</code> 操作：<code>import _ &quot;github.com/go-sql-driver/mysql&quot;</code></p><p><code>_ </code> 操作是引入某个包，但不直接使用包里的函数，而是调用该包里面的 <code>init</code> 函数，比如这个 <code>mysql</code> 包的导入。此外在开发中，由于某种原因某个原来导入的包现在不再使用，也可以采用这种方式处理。</p></li></ul><h2 id="标准库" tabindex="-1">标准库 <a class="header-anchor" href="#标准库" aria-hidden="true">#</a></h2><p>在 Go 的安装文件里包含了一些可以直接使用的包，即标准库。在 Windows 下，标准库的位置在 Go 根目录下的子目录 pkg\\windows_386 中；在 Linux 下，标准库在 Go 根目录下的子目录 pkg\\linux_amd64 中（如果是安装的是 32 位，则在 linux_386 目录中）。Go 的标准库包含了大量的包（如：fmt 和 os）, 在$GoROOT/src中可以看到源码，也可以根据情况自行重新编译。</p><p>完整列表可以在 Go Walker 查看。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">    unsafe: 包含了一些打破 Go 语言“类型安全”的命令，一般的程序中不会被使用，</span></span>
<span class="line"><span style="color:#A6ACCD;">            可用在 C/C++ 程序的调用中。</span></span>
<span class="line"><span style="color:#A6ACCD;">    syscall-os-os/exec:</span></span>
<span class="line"><span style="color:#A6ACCD;">        os: 提供给我们一个平台无关性的操作系统功能接口，采用类Unix设计，</span></span>
<span class="line"><span style="color:#A6ACCD;">            隐藏了不同操作系统间差异，让不同的文件系统和操作系统对象表现一致。</span></span>
<span class="line"><span style="color:#A6ACCD;">        os/exec: 提供我们运行外部操作系统命令和程序的方式。</span></span>
<span class="line"><span style="color:#A6ACCD;">        syscall: 底层的外部包，提供了操作系统底层调用的基本接口。</span></span>
<span class="line"><span style="color:#A6ACCD;">    archive/tar 和 /zip-compress：压缩(解压缩)文件功能。</span></span>
<span class="line"><span style="color:#A6ACCD;">    fmt-io-bufio-path/filepath-flag:</span></span>
<span class="line"><span style="color:#A6ACCD;">        fmt: 提供了格式化输入输出功能。</span></span>
<span class="line"><span style="color:#A6ACCD;">        io: 提供了基本输入输出功能，大多数是围绕系统功能的封装。</span></span>
<span class="line"><span style="color:#A6ACCD;">        bufio: 缓冲输入输出功能的封装。</span></span>
<span class="line"><span style="color:#A6ACCD;">        path/filepath: 用来操作在当前系统中的目标文件名路径。</span></span>
<span class="line"><span style="color:#A6ACCD;">        flag: 对命令行参数的操作。　　</span></span>
<span class="line"><span style="color:#A6ACCD;">    strings-strconv-unicode-regexp-bytes:</span></span>
<span class="line"><span style="color:#A6ACCD;">        strings: 提供对字符串的操作。</span></span>
<span class="line"><span style="color:#A6ACCD;">        strconv: 提供将字符串转换为基础类型的功能。</span></span>
<span class="line"><span style="color:#A6ACCD;">        unicode: 为 unicode 型的字符串提供特殊的功能。</span></span>
<span class="line"><span style="color:#A6ACCD;">        regexp: 正则表达式功能。</span></span>
<span class="line"><span style="color:#A6ACCD;">        bytes: 提供对字符型分片的操作。</span></span>
<span class="line"><span style="color:#A6ACCD;">    math-math/cmath-math/big-math/rand-sort:</span></span>
<span class="line"><span style="color:#A6ACCD;">        math: 基本的数学函数。</span></span>
<span class="line"><span style="color:#A6ACCD;">        math/cmath: 对复数的操作。</span></span>
<span class="line"><span style="color:#A6ACCD;">        math/rand: 伪随机数生成。</span></span>
<span class="line"><span style="color:#A6ACCD;">        sort: 为数组排序和自定义集合。</span></span>
<span class="line"><span style="color:#A6ACCD;">        math/big: 大数的实现和计算。 　　</span></span>
<span class="line"><span style="color:#A6ACCD;">    container-/list-ring-heap: 实现对集合的操作。</span></span>
<span class="line"><span style="color:#A6ACCD;">        list: 双链表。</span></span>
<span class="line"><span style="color:#A6ACCD;">        ring: 环形链表。</span></span>
<span class="line"><span style="color:#A6ACCD;">   time-log:</span></span>
<span class="line"><span style="color:#A6ACCD;">        time: 日期和时间的基本操作。</span></span>
<span class="line"><span style="color:#A6ACCD;">        log: 记录程序运行时产生的日志。</span></span>
<span class="line"><span style="color:#A6ACCD;">    encoding/Json-encoding/xml-text/template:</span></span>
<span class="line"><span style="color:#A6ACCD;">        encoding/Json: 读取并解码和写入并编码 Json 数据。</span></span>
<span class="line"><span style="color:#A6ACCD;">        encoding/xml:简单的 XML1.0 解析器。</span></span>
<span class="line"><span style="color:#A6ACCD;">        text/template:生成像 HTML 一样的数据与文本混合的数据驱动模板。</span></span>
<span class="line"><span style="color:#A6ACCD;">    net-net/http-html:</span></span>
<span class="line"><span style="color:#A6ACCD;">        net: 网络数据的基本操作。</span></span>
<span class="line"><span style="color:#A6ACCD;">        http: 提供了一个可扩展的 HTTP 服务器和客户端，解析 HTTP 请求和回复。</span></span>
<span class="line"><span style="color:#A6ACCD;">        html: HTML5 解析器。</span></span>
<span class="line"><span style="color:#A6ACCD;">    runtime: Go 程序运行时的交互操作，例如垃圾回收和协程创建。</span></span>
<span class="line"><span style="color:#A6ACCD;">    reflect: 实现通过程序运行时反射，让程序操作任意类型的变量。</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h2 id="包的初始化" tabindex="-1">包的初始化 <a class="header-anchor" href="#包的初始化" aria-hidden="true">#</a></h2><p>Go 语言中 <code>init()</code> 函数常用于包的初始化，该函数是 Go 语言的一个重要特性，有下面的特征：</p><ul><li><code>init</code> 函数是用于程序执行前做包的初始化的函数，比如初始化包里的变量等</li><li>每个包可以拥有多个 <code>init</code> 函数</li><li>包的每个源文件也可以拥有多个 <code>init</code> 函数</li><li>同一个包中多个 <code>init()</code> 函数的执行顺序不定</li><li>不同包的 <code>init()</code> 函数按照包导入的依赖关系决定该函数的执行顺序</li><li><code>init()</code> 函数不能被其他函数调用，其在 <code>main</code> 函数执行之前，自动被调用</li></ul><p>Go 程序的执行（程序启动）顺序如下：</p><p>程序的初始化和执行都起始于 <code>main</code> 包。如果 <code>main</code> 包还导入了其它的包，那么就会在编译时将它们依次导入。有时一个包会被多个包同时导入，那么它只会被导入一次（例如很多包可能都会用到 <code>fmt</code> 包，但它只会被导入一次，因为没有必要导入多次）。当一个包被导入时，如果该包还导入了其它的包，那么会先将其它包导入进来，然后再对这些包中的包级常量和变量进行初始化，接着执行 <code>init</code> 函数（如果有的话），依次类推。等所有被导入的包都加载完毕了，就会开始对 <code>main</code> 包中的包级常量和变量进行初始化，然后执行 <code>main</code> 包中的 <code>init</code> 函数（如果存在的话），最后执行 <code>main</code> 函数。</p>`,38),p=[e];function c(t,i,d,r,C,A){return n(),a("div",null,p)}const D=s(l,[["render",c]]);export{y as __pageData,D as default};
