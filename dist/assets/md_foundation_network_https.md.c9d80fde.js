import{_ as t,o as p,c as s,a as i}from"./app.3caa01d5.js";const n="/imgs/foundation/network/https-1.png",o="/imgs/foundation/network/https-2.png",r="/imgs/foundation/network/https-3.png",l="/imgs/foundation/network/https-4.png",e="/imgs/foundation/network/https-5.png",T="/imgs/foundation/network/https-6.png",a="/imgs/foundation/network/https-7.png",h="/imgs/foundation/network/https-8.png",d="/imgs/foundation/network/https-9.png",c="/imgs/foundation/network/https-10.png",C=JSON.parse('{"title":"HTTPS","description":"","frontmatter":{},"headers":[{"level":2,"title":"为什么需要 HTTPS","slug":"为什么需要-https","link":"#为什么需要-https","children":[]},{"level":2,"title":"HTTP 与 HTTPS 的主要区别","slug":"http-与-https-的主要区别","link":"#http-与-https-的主要区别","children":[]},{"level":2,"title":"HTTPS 建立过程","slug":"https-建立过程","link":"#https-建立过程","children":[]},{"level":2,"title":"HTTPS 的缺点","slug":"https-的缺点","link":"#https-的缺点","children":[]}],"relativePath":"md/foundation/network/https.md","lastUpdated":1676899703000}'),S={name:"md/foundation/network/https.md"},g=i('<h1 id="https" tabindex="-1">HTTPS <a class="header-anchor" href="#https" aria-hidden="true">#</a></h1><h2 id="为什么需要-https" tabindex="-1">为什么需要 HTTPS <a class="header-anchor" href="#为什么需要-https" aria-hidden="true">#</a></h2><p>超文本传输协议 HTTP 协议被用于在 Web 浏览器和网站服务器之间传递信息，HTTP 协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了 Web 浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP 协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。</p><p>为了解决 HTTP 协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议 HTTPS，为了数据传输的安全，HTTPS 在 HTTP 的基础上加入了 SSL / TLS 协议，SSL / TLS 依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p><p>HTTPS 协议是由 SSL / TLS + HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 HTTP 协议安全。</p><p>HTTPS 协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</p><h2 id="http-与-https-的主要区别" tabindex="-1">HTTP 与 HTTPS 的主要区别 <a class="header-anchor" href="#http-与-https-的主要区别" aria-hidden="true">#</a></h2><ul><li>HTTPS 协议需要到 CA 申请证书，一般免费证书较少，因而需要一定费用</li><li>HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL / TLS 加密传输协议</li><li>HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443</li><li>HTTP 的连接很简单，是无状态的；HTTPS 协议是由 SSL / TLS + HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全</li></ul><h2 id="https-建立过程" tabindex="-1">HTTPS 建立过程 <a class="header-anchor" href="#https-建立过程" aria-hidden="true">#</a></h2><p>HTTPS 的大体建立 SSL 的过程如下所示：</p><p><img src="'+n+'" alt=""></p><p>下面解释为什么这么做：</p><ol><li><p><strong>公钥和私钥</strong></p><p>RSA 是指非对称加密，加密结果是有一对秘钥，<strong>用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据， 只有对应的私钥才能解密</strong></p><p>所以我们可以派发公钥，自己保留好私钥就行了</p><p><img src="'+o+'" alt=""></p></li><li><p><strong>非对称加密的缺点</strong></p><p>非对称加密时需要使用到接收方的公匙对消息进行加密，但是公匙不是保密的，任何人都可以拿到，中间人也可以。那么中间人可以做两件事，第一件是中间人可以在客户端与服务器交换公匙的时候，将客户端的公匙替换成自己的。这样服务器拿到的公匙将不是客户端的，而是中间人的。服务器也无法判断公匙来源的正确性。第二件是中间人可以不替换公匙，但是他可以截获客户端发来的消息，然后篡改，然后用服务器的公匙加密再发往服务器，服务器将收到错误的消息。</p><p>中间商可以冒充服务器篡改公钥，如下图：</p><p><img src="'+r+'" alt=""></p></li><li><p><strong>数字签名</strong></p><p>数字签名是个什么东西呢？它是信息的指纹。但是这不是重点，重点是数字签名的生成过程。数字签名的生成有两个步骤：</p><ul><li><p>对明文进行哈希，得到一串哈希值</p></li><li><p>对第一步得到的哈希值用私钥加密</p></li></ul><p><img src="'+l+'" alt=""></p><p>数字签名是如何使用的呢？其实看一张图就明白了。数字签名会随着内容一起被发送出去，接收方首先用公钥解密数字签名得到哈希值 h1，然后对内容用同样的算法计算哈希值 h2，如果 h1 = h2，那么说明内容没有被串改过。</p><p><img src="'+e+'" alt=""></p><p>然而这个过程也存在风险，如果中间商篡改了公钥，那么他就可以伪造数字签名，一样完蛋。如下：</p><p><img src="'+T+'" alt=""></p><p>所以引入数字证书。</p></li><li><p><strong>数字证书</strong></p><p>数字证书包含两部分内容： <strong>证书信息</strong>和<strong>数字签名</strong></p><p>这里的证书信息中就包含了服务器发送过来的信息（包括服务器公钥），当然还有一些其他信息，比如证书名称、发布机构、有限期、哈希算法等。</p><p>数字签名就是对证书信息进行哈希，然后用 CA 认证中心的私钥加密的结果。</p><p><img src="'+a+'" alt=""></p><div class="danger custom-block"><p class="custom-block-title">DANGER</p><p>这里特别强调数字签名是用 CA 认证中心的私钥加密的，因为这样才能防止中间商串改公钥。这里还有一点需要注意，那就是操作系统会自动安装 CA 认证中心的公钥，所以，每个客户端都默认有 CA 认证中心的公钥。</p></div><p>引入数字证书后的使用过程如下：</p><p><img src="'+h+'" alt=""></p><p>如果中间商想伪造数字证书，篡改数字证书中的公钥，由于中间商没有 CA 认证中心的私钥，无法伪造数字签名，于是也就无法伪造数字证书了：</p><p><img src="'+d+'" alt=""></p><p>但是这样就万无一失了吗？并不是，如果中间商也在 CA 认证中心注册了数字证书，并且用这个合法的数字证书替换了服务器的数字证书，还是会完蛋。但这就不是我们该操心的问题了，这是 CA 认证中心该考虑的问题，应该给什么人发证书，拒绝给什么人发证书。只有 CA 认证中心能够区分好人和坏人，我们才是安全的。</p><p>其实到最后就是客户端把对服务器的信任委托给了 CA 认证中心，因为服务器是不一定可信的，那就创造一个相对一定可信的第三方。</p></li><li><p><strong>证书校验</strong></p><p>根据以上内容，我们可以得出在 HTTPS 通信中，客户端整数校验的过程：</p><p><img src="'+c+'" alt=""></p></li><li><p><strong>对称加密通信</strong></p><p>真正的 HTTPS 通信并不是通过公钥和私钥加密的，公钥和私钥只用在握手过程中，当客户端请求到真正的公钥后，会生成一个随机数（对称密钥）并用公钥加密，发送给服务器，后续的通信就用对称密钥加密了。这样做的原因是非对称加密的性能相对对称加密来说会慢上几倍甚至几百倍，比较消耗系统资源。正是因为如此，HTTPS 将两种加密结合了起来。</p></li></ol><h2 id="https-的缺点" tabindex="-1">HTTPS 的缺点 <a class="header-anchor" href="#https-的缺点" aria-hidden="true">#</a></h2><p>虽然说HTTPS有很大的优势，但其相对来说，还是存在不足之处的：</p><ul><li>HTTPS 协议握手阶段比较费时，会使页面的加载时间延长近 50%，增加 10% 到 20% 的耗电</li><li>HTTPS 连接缓存不如 HTTP 高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响</li><li>SSL 证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用</li><li>SSL 证书通常需要绑定 IP，不能在同一 IP 上绑定多个域名，IPv4 资源不可能支撑这个消耗</li><li>HTTPS 协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL 证书的信用链体系并不安全，特别是在某些国家可以控制 CA 根证书的情况下，中间人攻击一样可行</li></ul>',16),P=[g];function _(m,H,u,f,k,A){return p(),s("div",null,P)}const w=t(S,[["render",_]]);export{C as __pageData,w as default};
