import{_ as n,o as s,c,b as t,d as p,e,w as o,a as i,r}from"./app.3caa01d5.js";const a="/imgs/foundation/network/tcp-1.png",d="/imgs/foundation/network/tcp-2.png",_="/imgs/foundation/network/tcp-3.png",u="/imgs/foundation/network/tcp-4.png",K=JSON.parse('{"title":"TCP 协议","description":"","frontmatter":{},"headers":[{"level":2,"title":"TCP 协议的特点","slug":"tcp-协议的特点","link":"#tcp-协议的特点","children":[]},{"level":2,"title":"TCP 报文段","slug":"tcp-报文段","link":"#tcp-报文段","children":[]},{"level":2,"title":"TCP 连接管理","slug":"tcp-连接管理","link":"#tcp-连接管理","children":[{"level":3,"title":"TCP 连接的建立","slug":"tcp-连接的建立","link":"#tcp-连接的建立","children":[]},{"level":3,"title":"TCP 连接的释放","slug":"tcp-连接的释放","link":"#tcp-连接的释放","children":[]}]}],"relativePath":"md/foundation/network/tcp.md","lastUpdated":1676810844000}'),C={name:"md/foundation/network/tcp.md"},T=i('<h1 id="tcp-协议" tabindex="-1">TCP 协议 <a class="header-anchor" href="#tcp-协议" aria-hidden="true">#</a></h1><h2 id="tcp-协议的特点" tabindex="-1">TCP 协议的特点 <a class="header-anchor" href="#tcp-协议的特点" aria-hidden="true">#</a></h2><p><img src="'+a+'" alt=""></p><h2 id="tcp-报文段" tabindex="-1">TCP 报文段 <a class="header-anchor" href="#tcp-报文段" aria-hidden="true">#</a></h2><p>TCP 传送的数据单元称为报文段。一个 TCP 报文段分为 TCP 首部和 TCP 数据两部分，整个 TCP 报文段作为 IP 数据报的数据部分封装在 IP 数据报中，如图所示：</p><p><img src="'+d+'" alt=""></p><p>各字段意义如下：</p>',7),P=t("p",null,[t("strong",null,"序号")],-1),h=t("p",null,[t("strong",null,"确认号")],-1),g=t("strong",null,"数据偏移",-1),A=t("p",null,"TCP 报文段的数据其实处距离 TCP 报文段的起始处有多远，以 4 B 为单位",-1),S=i("<li><p><strong>保留字段</strong></p><p>占 6 位，保留为今后使用，但目前应置为 0，该字段可以忽略不计</p></li><li><p><strong>紧急位 URG</strong></p><p>URG = 1 时，表明此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用在缓存里排队，配合紧急指针字段使用</p></li><li><p><strong>确认位 ACK</strong></p><p>ACK = 1 时确认号有效，在链接建立后索要传送的报文段都必须把 ACK 置为 1</p></li><li><p><strong>推送位 PSH</strong></p><p>PSH = 1时，接收方尽快交付接收应用进程，不再等到缓存填满再向上交付</p></li><li><p><strong>复位位 RST</strong></p><p>RST = 1 时，表明 TCP 连接中出现严重错误，必须释放连接，然后重新建立传输连接</p></li><li><p><strong>同步位 SYN</strong></p><p>SYN = 1时，表明是一个连接请求/连接接受报文</p></li><li><p><strong>终止位 FIN</strong></p><p>FIN = 1 时，表明此报文段发送方数据已发完，要求释放连接</p></li><li><p><strong>窗口字段</strong></p><p>指的是发送本报文段的一方的接收窗口，即现在允许对方发送的数据量</p></li><li><p><strong>检验和</strong></p><p>检验首部+数据，检验时要加上 12 B 伪首部，第四个字段为 6</p></li><li><p><strong>紧急指针</strong></p><p>URG = 1 时才有意义，指出本报文段中紧急数据的字节数</p></li><li><p><strong>选项</strong></p><p>最大报文段长度 MSS、窗口扩大、时间戳、选择确认…</p></li>",11),k=i('<h2 id="tcp-连接管理" tabindex="-1">TCP 连接管理 <a class="header-anchor" href="#tcp-连接管理" aria-hidden="true">#</a></h2><p>TCP 是面向连接的协议，因此每个 TCP 连接都有三个阶段：建立连接、数据传送和连接释放。TCP 连接的管理就是使运输连接的建立和释放都能正常进行。</p><p>在 TCP 连接建立的过程中，要解决以下三个问题：</p><ul><li>要使每一方都能够确知对方的存在</li><li>要允许双方协商一些参数（如最大窗口值、是否使用窗口扩大项、时间戳选项及服务质量等）</li><li>能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配</li></ul><blockquote><p>TCP 把连接作为最基本的抽象，每条 TCP 连接有两个端点，TCP 连接的端点不是主机，不是主机的 IP 地址，不是应用进程，也不是传输层的协议端口。TCP 连接的端口称为套接字（socket），端口拼接到 IP 地址即构成套接字。</p></blockquote><blockquote><p>每条 TCP 连接唯一地被通信两端的两个端点确定</p></blockquote><p>TCP 连接的建立采用<strong>客户端/服务器</strong>方式。主动发起连接建立的应用程序称为客户端，而被动等待连接建立的应用程序称为服务器。</p><h3 id="tcp-连接的建立" tabindex="-1">TCP 连接的建立 <a class="header-anchor" href="#tcp-连接的建立" aria-hidden="true">#</a></h3><p><img src="'+_+'" alt=""></p><ul><li><p>第一段的意思是 SYN = 1: A 要建立连接了！ seq = x（随机）: 因为还没有数据，所以写什么都无所谓</p></li><li><p>第二段的意思是 SYN = 1: 我 B 同意你 A 建立连接！ ACK = 1: 连接建立了，之后的 ACK 必须都置为 1 seq = y（随机）: 因为还没有数据，所以写什么都无所谓 ack = x + 1：之前发送方 A 说发送的是第 x 位数据（虽然发送方是瞎说的），所以我 B 要的是 x + 1 位数据</p></li><li><p>第三段的意思是 SYN = 0: SYN 只有在建立连接时才为 1，其他时候均设为 0 ACK = 1: 连接建立了，之后的 ACK 必须都置为 1 seq = x + 1: 我 A 发送的报文段的第一个字节就是 x + 1 ack = y + 1: 之前接收方 B 说发送的是第 y 位数据（虽然接收方是瞎说的），所以我 A 要的是 y + 1 位数据</p></li></ul><blockquote><p>注意一下，TCP 是双向的，所以不存在绝对不变的发送方接收方，这里的两台主机都同时是发送方和接收方</p></blockquote><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>这里会存在一个问题，SYN 洪泛攻击：</p><p>SYN 洪泛攻击发生在 OSI 第四层，这种方式利用 TCP 协议的特性，就是三次握手。攻击者发送 TCP SYN，SYN 是 TCP 三次握手中的第一个数据包，而当服务器返回 ACK 后，该攻击者就不对其进行再确认，那这个 TCP 连接就处于挂起状态，也就是所谓的半连接状态，服务器收不到再确认的话，还会重复发送 ACK 给攻击者，这样更加会浪费服务器的资源。攻击者就对服务器发送非常大量的这种 TCP 连接，由于每一个都没法完成三次握手，所以在服务器上，这些 TCP 连接会因为挂起状态而消耗 CPU 和内存，最后服务器可能死机，就无法为正常用户提供服务了。</p></div><h3 id="tcp-连接的释放" tabindex="-1">TCP 连接的释放 <a class="header-anchor" href="#tcp-连接的释放" aria-hidden="true">#</a></h3><p><img src="'+u+'" alt=""></p><ul><li><p>第一段的意思是 FIN = 1：A 要释放连接了！ seq = u：发了好多数据，这里只是用 u 指代一下，这里 u 是有确定值的</p></li><li><p>第二段的意思是 ACK = 1：连接建立了，之后的 ACK 必须都置为 1 seq = v：发了好多数据，这里只是用 v 指代一下，这里 v 是有确定值的 ack = u + 1：之前发送方 A 说发送的是第 u 位数据，所以我 B 要的是 u + 1 位数据（尽管此时 A 已经决定释放连接了）</p></li><li><p>第三段的意思是 FIN = 1：B 要释放连接了！ ACK = 1：连接建立了，之后的 ACK 必须都置为 1 seq = w：发了好多数据，这里只是用 w 指代一下，这里 w 是有确定值的 ack = u + 1：之前发送方 A 说发送的是第 u 位数据，所以我 B 要的是 u + 1 位数据（因为 A 直接不发数据了，所以第二段第三段的 ack 都是 u + 1）</p></li><li><p>第四段的意思是 ACK = 1：连接建立了，之后的ACK必须都置为1 seq = u + 1：之前发的数据时第 u 位数据，B 也要第 u + 1 位数据，所以我发第 u + 1 位数据 ack = w + 1：之前发送方 B 说发送的是第 w 位数据，所以我 A 要的是 w + 1 位数据</p></li></ul><div class="tip custom-block"><p class="custom-block-title">为什么需要等待计时 2 MSL？</p><p>因为这样可以保证 B 可以收到 A 的终止报文段进而进入关闭状态 比如说如果 A 的第四段报文丢失，那么等待一个 MSL 之后 B 就会重传第三段报文，花费小于1 MSL之后 A 就会再收到第三段报文，之后就可以再次向 B 发送第四段报文提示 B 关闭连接。</p></div>',16);function m(f,N,b,x,B,I){const l=r("font");return s(),c("div",null,[T,t("ul",null,[t("li",null,[P,t("p",null,[p("在一个 TCP 连接中传送的字节流中的每一个字节都按顺序编号，本字段表示本报文段所发送数据的"),e(l,{color:"red"},{default:o(()=>[p("第一个字节的序号")]),_:1})])]),t("li",null,[h,e(l,{color:"red"},{default:o(()=>[p("期望")]),_:1}),p("收到对方下一个报文段的第一个数据字节的序号。若确认号为 N，则证明到序号 N-1 为止的所有数据都已正确收到")]),t("li",null,[t("p",null,[g,p("（"),e(l,{color:"red"},{default:o(()=>[p("首部长度")]),_:1}),p("）")]),A]),S]),k])}const w=n(C,[["render",m]]);export{K as __pageData,w as default};
