# TCP 协议

## TCP 协议的特点

![](/imgs/foundation/network/tcp-1.png)

## TCP 报文段

TCP 传送的数据单元称为报文段。一个 TCP 报文段分为 TCP 首部和 TCP 数据两部分，整个 TCP 报文段作为 IP 数据报的数据部分封装在 IP 数据报中，如图所示：

![](/imgs/foundation/network/tcp-2.png)

各字段意义如下：

- **序号**

  在一个 TCP 连接中传送的字节流中的每一个字节都按顺序编号，本字段表示本报文段所发送数据的<font color="red">第一个字节的序号</font>

- **确认号**

  <font color="red">期望</font>收到对方下一个报文段的第一个数据字节的序号。若确认号为 N，则证明到序号 N-1 为止的所有数据都已正确收到

- **数据偏移**（<font color="red">首部长度</font>）

  TCP 报文段的数据其实处距离 TCP 报文段的起始处有多远，以 4 B 为单位
- **保留字段**
  
  占 6 位，保留为今后使用，但目前应置为 0，该字段可以忽略不计
- **紧急位 URG**

  URG = 1 时，表明此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用在缓存里排队，配合紧急指针字段使用

- **确认位 ACK**

  ACK = 1 时确认号有效，在链接建立后索要传送的报文段都必须把 ACK 置为 1

- **推送位 PSH**

  PSH = 1时，接收方尽快交付接收应用进程，不再等到缓存填满再向上交付

- **复位位 RST**

  RST = 1 时，表明 TCP 连接中出现严重错误，必须释放连接，然后重新建立传输连接

- **同步位 SYN**

  SYN = 1时，表明是一个连接请求/连接接受报文

- **终止位 FIN**

  FIN = 1 时，表明此报文段发送方数据已发完，要求释放连接

- **窗口字段**

  指的是发送本报文段的一方的接收窗口，即现在允许对方发送的数据量

- **检验和**

  检验首部+数据，检验时要加上 12 B 伪首部，第四个字段为 6

- **紧急指针**

  URG = 1 时才有意义，指出本报文段中紧急数据的字节数

- **选项**

  最大报文段长度 MSS、窗口扩大、时间戳、选择确认…

## TCP 连接管理

TCP 是面向连接的协议，因此每个 TCP 连接都有三个阶段：建立连接、数据传送和连接释放。TCP 连接的管理就是使运输连接的建立和释放都能正常进行。

在 TCP 连接建立的过程中，要解决以下三个问题：

- 要使每一方都能够确知对方的存在
- 要允许双方协商一些参数（如最大窗口值、是否使用窗口扩大项、时间戳选项及服务质量等）
- 能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配

> TCP 把连接作为最基本的抽象，每条 TCP 连接有两个端点，TCP 连接的端点不是主机，不是主机的 IP 地址，不是应用进程，也不是传输层的协议端口。TCP 连接的端口称为套接字（socket），端口拼接到 IP 地址即构成套接字。

> 每条 TCP 连接唯一地被通信两端的两个端点确定

TCP 连接的建立采用**客户端/服务器**方式。主动发起连接建立的应用程序称为客户端，而被动等待连接建立的应用程序称为服务器。

### TCP 连接的建立

![](/imgs/foundation/network/tcp-3.png)

- 第一段的意思是
  SYN = 1:  A 要建立连接了！
  seq = x（随机）: 因为还没有数据，所以写什么都无所谓

- 第二段的意思是
  SYN = 1: 我 B 同意你 A 建立连接！
  ACK = 1: 连接建立了，之后的 ACK 必须都置为 1
  seq = y（随机）: 因为还没有数据，所以写什么都无所谓
  ack = x + 1：之前发送方 A 说发送的是第 x 位数据（虽然发送方是瞎说的），所以我 B 要的是 x + 1 位数据

- 第三段的意思是
  SYN = 0: SYN 只有在建立连接时才为 1，其他时候均设为 0
  ACK = 1: 连接建立了，之后的 ACK 必须都置为 1
  seq = x + 1: 我 A 发送的报文段的第一个字节就是 x + 1
  ack = y + 1: 之前接收方 B 说发送的是第 y 位数据（虽然接收方是瞎说的），所以我 A 要的是 y + 1 位数据

> 注意一下，TCP 是双向的，所以不存在绝对不变的发送方接收方，这里的两台主机都同时是发送方和接收方

::: tip

这里会存在一个问题，SYN 洪泛攻击：

SYN 洪泛攻击发生在 OSI 第四层，这种方式利用 TCP 协议的特性，就是三次握手。攻击者发送 TCP SYN，SYN 是 TCP 三次握手中的第一个数据包，而当服务器返回 ACK 后，该攻击者就不对其进行再确认，那这个 TCP 连接就处于挂起状态，也就是所谓的半连接状态，服务器收不到再确认的话，还会重复发送 ACK 给攻击者，这样更加会浪费服务器的资源。攻击者就对服务器发送非常大量的这种 TCP 连接，由于每一个都没法完成三次握手，所以在服务器上，这些 TCP 连接会因为挂起状态而消耗 CPU 和内存，最后服务器可能死机，就无法为正常用户提供服务了。

:::

### TCP 连接的释放

![](/imgs/foundation/network/tcp-4.png)

- 第一段的意思是
  FIN = 1：A 要释放连接了！
  seq = u：发了好多数据，这里只是用 u 指代一下，这里 u 是有确定值的

- 第二段的意思是
  ACK = 1：连接建立了，之后的 ACK 必须都置为 1
  seq = v：发了好多数据，这里只是用 v 指代一下，这里 v 是有确定值的
  ack = u + 1：之前发送方 A 说发送的是第 u 位数据，所以我 B 要的是 u + 1 位数据（尽管此时 A 已经决定释放连接了）

- 第三段的意思是
  FIN = 1：B 要释放连接了！
  ACK = 1：连接建立了，之后的 ACK 必须都置为 1
  seq = w：发了好多数据，这里只是用 w 指代一下，这里 w 是有确定值的
  ack = u + 1：之前发送方 A 说发送的是第 u 位数据，所以我 B 要的是 u + 1 位数据（因为 A 直接不发数据了，所以第二段第三段的 ack 都是 u + 1）

- 第四段的意思是
  ACK = 1：连接建立了，之后的ACK必须都置为1
  seq = u + 1：之前发的数据时第 u 位数据，B 也要第 u + 1 位数据，所以我发第 u + 1 位数据
  ack = w + 1：之前发送方 B 说发送的是第 w 位数据，所以我 A 要的是 w + 1 位数据

::: tip 为什么需要等待计时 2 MSL？
因为这样可以保证 B 可以收到 A 的终止报文段进而进入关闭状态
比如说如果 A 的第四段报文丢失，那么等待一个 MSL 之后 B 就会重传第三段报文，花费小于1 MSL之后 A 就会再收到第三段报文，之后就可以再次向 B 发送第四段报文提示 B 关闭连接。

:::







